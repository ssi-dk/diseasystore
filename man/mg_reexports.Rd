% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mg_reexports.R
\name{mg_get_connection}
\alias{mg_get_connection}
\alias{mg_reexports}
\alias{mg_get_tables}
\alias{mg_get_table}
\alias{mg_table_exists}
\alias{mg_id}
\alias{mg_slice_time}
\alias{mg_inner_join}
\alias{mg_left_join}
\alias{mg_mg_right_join}
\alias{mg_mg_right_join.tbl_dbi}
\alias{mg_mg_right_join.tbl_SQLiteConnection}
\alias{mg_right_join}
\alias{mg_join_na_sql}
\alias{mg_select_na_sql}
\alias{mg_join_warn}
\alias{mg_join_warn_experimental}
\alias{mg_interlace_sql}
\alias{mg_digest_to_checksum}
\alias{mg_digest_to_checksum_native_md5}
\alias{mg_digest_to_checksum_internal}
\alias{mg_digest_to_checksum_internal.default}
\alias{unite.tbl_dbi}
\alias{mg_create_table}
\alias{mg_update_snapshot}
\alias{mg_filter_keys}
\alias{mg_db_timestamp}
\alias{mg_is.historical}
\alias{mg_nrow}
\alias{mg_Logger}
\alias{mg_create_logs_if_missing}
\alias{mg_age_labels}
\alias{mg_assert_dbtable_like}
\alias{mg_assert_timestamp_like}
\alias{mg_assert_data_like}
\alias{mg_assert_id_like}
\title{Opens connection to the database}
\usage{
mg_get_connection(
  drv = RPostgres::Postgres(),
  host = NULL,
  port = NULL,
  dbname = NULL,
  user = NULL,
  password = NULL,
  timezone = NULL,
  timezone_out = NULL,
  ...
)

mg_get_tables(conn, pattern = NULL)

mg_get_table(
  conn,
  db_table_id = NULL,
  slice_ts = NA,
  include_slice_info = FALSE
)

mg_table_exists(conn, db_table_id)

mg_id(db_table_id, conn = NULL)

mg_slice_time(.data, slice_ts, from_ts = from_ts, until_ts = until_ts)

mg_inner_join(x, y, by = NULL, na_by = NULL, ...)

mg_left_join(x, y, by = NULL, na_by = NULL, ...)

mg_mg_right_join(x, y, sql_on, renamer, ...)

\method{mg_mg_right_join}{tbl_dbi}(x, y, sql_on, renamer, ...)

\method{mg_mg_right_join}{tbl_SQLiteConnection}(x, y, sql_on, renamer, ...)

mg_right_join(x, y, by = NULL, na_by = NULL, ...)

mg_join_na_sql(by, na_by)

mg_select_na_sql(x, y, by, na_by, left = TRUE)

mg_join_warn()

mg_join_warn_experimental()

mg_interlace_sql(tables, by = NULL, colnames = NULL)

mg_digest_to_checksum(.data, col = "checksum", exclude = NULL, warn = TRUE)

mg_digest_to_checksum_native_md5(.data, col)

mg_digest_to_checksum_internal(.data, col)

\method{mg_digest_to_checksum_internal}{default}(.data, col)

\method{unite}{tbl_dbi}(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)

mg_create_table(.data, conn = NULL, db_table_id = NULL, temporary = TRUE, ...)

mg_update_snapshot(
  .data,
  conn,
  db_table,
  timestamp,
  filters = NULL,
  message = NULL,
  tic = Sys.time(),
  log_path = getOption("mg.log_path"),
  log_table_id = getOption("mg.log_table_id"),
  enforce_chronological_order = TRUE
)

mg_filter_keys(.data, filters, by = NULL, na_by = NULL)

mg_db_timestamp(timestamp, conn)

mg_is.historical(.data)

mg_nrow(.data)

mg_create_logs_if_missing(log_table, conn)

mg_age_labels(age_cuts)

mg_assert_dbtable_like(db_table, ..., add = NULL)

mg_assert_timestamp_like(timestamp, ..., add = NULL)

mg_assert_data_like(.data, ..., add = NULL)

mg_assert_id_like(mg_id, ..., add = NULL)
}
\arguments{
\item{drv}{An object that inherits from DBIDriver or an existing DBIConnection (default: RPostgres::Postgres())}

\item{host}{Character string giving the ip of the host to connect to}

\item{port}{Host port to connect to (numeric)}

\item{dbname}{Name of the database located at the host}

\item{user}{Username to login with}

\item{password}{Password to login with}

\item{timezone}{Sets the timezone of DBI::dbConnect()}

\item{timezone_out}{Sets the timezone_out of DBI::dbConnect()}

\item{...}{Parameters passed to checkmate::check_*}

\item{conn}{An object that inherits from DBIConnection (as generated by get_connection())'}

\item{pattern}{A regex pattern with which to subset the returned tables}

\item{db_table_id}{A \code{\link[DBI:Id]{DBI::Id()}} object or a character string readable by \link{mg_id}.}

\item{slice_ts}{The time / date to slice by}

\item{include_slice_info}{Default FALSE.
If set TRUE, the history columns "checksum", "from_ts", "until_ts" are returned also}

\item{.data}{Object to test if is data.table, data.frame, tbl or tibble}

\item{from_ts}{The name of the column in .data specifying valid from time (note: must be unquoted)}

\item{until_ts}{The name of the column in .data specifying valid until time (note: must be unquoted)}

\item{x, y}{A pair of lazy data frames backed by database queries.}

\item{by}{passed to mg_inner_join if different from NULL}

\item{na_by}{passed to mg_inner_join if different from NULL}

\item{sql_on}{A custom join predicate as an SQL expression.
Usually joins use column equality, but you can perform more complex
queries by supply \code{sql_on} which should be a SQL expression that
uses \code{LHS} and \code{RHS} aliases to refer to the left-hand side or
right-hand side of the join respectively.}

\item{renamer}{named list generated by mg_select_na_sql}

\item{left}{Boolean that control if joins is left (alternatively right) join}

\item{tables}{A list(!) of tables you want to combine is supplied here as
lazy_queries.}

\item{colnames}{If the time axes of validity is not called "valid_to" and
"valid_until" inside each lazy_query, you can specify their
names by supplying the arguments as a list
(e.g. c(t1.from = "\<colname\>", t2.until = "\<colname\>").
colnames must be named in same order as as given in tables
(i.e. t1, t2, t3, ...).}

\item{col}{The name of column the checksums will be placed in}

\item{exclude}{Columns to exclude from the checksum generation}

\item{warn}{Flag to warn if target column already exists in data}

\item{data}{A data frame.}

\item{sep}{Separator to use between values.}

\item{remove}{If \code{TRUE}, remove input columns from output data frame.}

\item{na.rm}{If \code{TRUE}, missing values will be removed prior to uniting
each value.}

\item{temporary}{Should the table be created as a temporary table?}

\item{db_table}{Object to test if is of class "tbl_dbi" or character on form "schema.table"}

\item{timestamp}{Object to test if is POSIX or character}

\item{filters}{A filter to subset data by.  if filters == NULL, no filtering occurs. Else, an mg_inner_join is performed using all columns of the filter}

\item{message}{A message to add to the log-file (useful for supplying metadata to the log)}

\item{tic}{A timestamp when computation began. If not supplied, it will be created at call-time.
(Used to more accurately convey how long runtime of the update process has been)}

\item{log_path}{The path where logs are stored.
If NULL, no file logs are created.}

\item{log_table_id}{A \code{\link[DBI:Id]{DBI::Id()}} object or a character string readable by \link{mg_id}, specifying the location of the log table.}

\item{enforce_chronological_order}{A logical that controls whether or not to check if timestamp of update is prior to timestamps in the DB}

\item{log_table}{A specification of where the logs should exist ("schema.table")}

\item{age_cuts}{The lower bound of the groups (0 is implicitly included)}

\item{add}{\code{AssertCollection} to add assertions to}

\item{mg_id}{Object to test if is of class "Id" or character on form "schema.table"}
}
\value{
An object that inherits from DBIConnection driver specified in drv

A data.frame containing table names in the DB

A "lazy" dataframe (tbl_lazy) generated using dbplyr

An object similar to .data

\if{html}{\out{<div class="sourceCode">}}\preformatted{     The combination of input queries with a single, interlaced
             valid_from / valid_until time axis
}\if{html}{\out{</div>}}

Invisibly returns the table as it looks on the destination (or locally if conn is NULL)

An object similar to .data

TRUE if .data contains the columns: "checksum", "from_ts", and "until_ts". FALSE otherwise

The number of records in the object

A vector of labels with zero-padded numerics so they can be sorted easily
}
\description{
Connects to the specified dbname of host:port using user and password from given arguments.
Certain drivers may use credentials stored in a file, such as ~/.pgpass (PostgreSQL)

Overloads the dplyr \emph{_join to accept an na_by argument.
By default, joining using SQL does not match on NA / NULL.
dbplyr has the option "na_matches = na" to match on NA / NULL but this is very inefficient
This function does the matching more efficiently.
If a column contains NA / NULL, give the argument to na_by to match during the join
If no na_by is given, the function defaults to using dplyr::}_join

The function "interlaces" the queries and combines their validity time axes
onto a single time axis

If filter = NULL, not filtering is done
If filter is different from NULL, the .data is filtered by a mg_inner_join using all columns of the filter:
\code{mg_inner_join(.data, filter, by = colnames(filter))}

by and na_by can overwrite the mg_inner_join columns used in the filtering

Create an object for logging database operations
}
\details{
This function generates a much faster sql statement for NA join compared to dbplyr's _join with na_matches = "na".
}
\seealso{
\link[DBI:Id]{DBI::Id} which this function wraps.

\link[dplyr:mutate-joins]{dplyr::mutate-joins} which this function wraps.

\link[dbplyr:join.tbl_sql]{dbplyr::join.tbl_sql} which this function wraps.

mg_filter_keys
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{log_path}}{(\code{character(1)})\cr
A directory where log file is written (if this is not NULL). Defaults to \code{getOption("mg.log_path")}.}

\item{\code{log_filename}}{(\code{character(1)})\cr
The name (basename) of the log file.}

\item{\code{log_tbl}}{The DB table used for logging. Class is connection-specific, but inherits from \code{tbl_dbi}.}

\item{\code{start_time}}{(\code{POSIXct(1)})\cr
The time at which data processing was started.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-mg_Logger-new}{\code{mg_Logger$new()}}
\item \href{#method-mg_Logger-log_info}{\code{mg_Logger$log_info()}}
\item \href{#method-mg_Logger-log_warn}{\code{mg_Logger$log_warn()}}
\item \href{#method-mg_Logger-log_error}{\code{mg_Logger$log_error()}}
\item \href{#method-mg_Logger-log_to_db}{\code{mg_Logger$log_to_db()}}
\item \href{#method-mg_Logger-clone}{\code{mg_Logger$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mg_Logger-new"></a>}}
\if{latex}{\out{\hypertarget{method-mg_Logger-new}{}}}
\subsection{Method \code{new()}}{
Create a new mg_Logger object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{mg_Logger$new(
  db_tablestring = NULL,
  log_table_id = getOption("mg.log_table_id"),
  log_conn = NULL,
  log_path = getOption("mg.log_path"),
  ts = NULL,
  start_time = Sys.time()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{db_tablestring}}{A string specifying the table being updated}

\item{\code{log_table_id}}{A \code{\link[DBI:Id]{DBI::Id()}} object or a character string readable by \link{mg_id}, specifying the location of the log table.}

\item{\code{log_conn}}{A database connection inheriting from \code{DBIConnection}}

\item{\code{log_path}}{The path where logs are stored.
If NULL, no file logs are created.}

\item{\code{ts}}{A timestamp describing the data being processed (≠ current time)}

\item{\code{start_time}}{The time at which data processing was started (defaults to \code{\link[=Sys.time]{Sys.time()}})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mg_Logger-log_info"></a>}}
\if{latex}{\out{\hypertarget{method-mg_Logger-log_info}{}}}
\subsection{Method \code{log_info()}}{
Write a line to log file
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{mg_Logger$log_info(..., tic = Sys.time(), log_type = "INFO")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{One or more character strings to be concatenated}

\item{\code{tic}}{The timestamp used by the log entry (default Sys.time())}

\item{\code{log_type}}{A character string which describes the severity of the log message}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mg_Logger-log_warn"></a>}}
\if{latex}{\out{\hypertarget{method-mg_Logger-log_warn}{}}}
\subsection{Method \code{log_warn()}}{
Write a warning to log file and generate warning.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{mg_Logger$log_warn(..., log_type = "WARNING")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{One or more character strings to be concatenated}

\item{\code{log_type}}{A character string which describes the severity of the log message}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mg_Logger-log_error"></a>}}
\if{latex}{\out{\hypertarget{method-mg_Logger-log_error}{}}}
\subsection{Method \code{log_error()}}{
Write an error to log file and stop execution
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{mg_Logger$log_error(..., log_type = "ERROR")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{One or more character strings to be concatenated}

\item{\code{log_type}}{A character string which describes the severity of the log message}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mg_Logger-log_to_db"></a>}}
\if{latex}{\out{\hypertarget{method-mg_Logger-log_to_db}{}}}
\subsection{Method \code{log_to_db()}}{
Write or update log table
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{mg_Logger$log_to_db(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Name-value pairs with which to update the log table}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mg_Logger-clone"></a>}}
\if{latex}{\out{\hypertarget{method-mg_Logger-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{mg_Logger$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
